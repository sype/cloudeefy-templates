apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: nextjs-build-{{APP_NAME}}
  namespace: argo
  labels:
    framework: nextjs
    app: {{APP_NAME}}
spec:
  entrypoint: build-and-deploy

  arguments:
    parameters:
    - name: repo-url
      value: "{{REPO_URL}}"
    - name: git-branch
      value: "main"
    - name: git-commit-sha
      value: "{{GIT_SHA}}"
    - name: image-name
      value: "{{REGISTRY}}/{{TENANT}}/{{IMAGE_NAME}}"
    - name: namespace
      value: "{{NAMESPACE}}"
    - name: app-name
      value: "{{APP_NAME}}"

  serviceAccountName: argo-workflow

  # Docker registry credentials
  volumes:
  - name: docker-config
    secret:
      secretName: scw-registry-secret
      items:
      - key: .dockerconfigjson
        path: config.json

  templates:
  - name: build-and-deploy
    steps:
    - - name: clone-repo
        template: git-clone

    - - name: install-dependencies
        template: npm-install
        arguments:
          artifacts:
          - name: source
            from: "{{steps.clone-repo.outputs.artifacts.source}}"

    - - name: run-tests
        template: run-tests
        arguments:
          artifacts:
          - name: source
            from: "{{steps.install-dependencies.outputs.artifacts.source}}"

    - - name: build-app
        template: build-nextjs
        arguments:
          artifacts:
          - name: source
            from: "{{steps.run-tests.outputs.artifacts.source}}"

    - - name: build-docker-image
        template: docker-build
        arguments:
          artifacts:
          - name: source
            from: "{{steps.build-app.outputs.artifacts.source}}"

    # Image Updater will detect the new image and update the deployment
    # No need for kubectl update steps

  - name: git-clone
    container:
      image: alpine/git:latest
      workingDir: /workspace
      command: [sh, -c]
      args:
        - |
          git clone {{workflow.parameters.repo-url}} .
          git checkout {{workflow.parameters.git-branch}}
          if [ "{{workflow.parameters.git-commit-sha}}" != "latest" ]; then
            git reset --hard {{workflow.parameters.git-commit-sha}} || echo "‚ö†Ô∏è  Commit SHA not found, using HEAD"
          fi
          echo "‚úì Cloned repository"
          echo "‚úì Branch: {{workflow.parameters.git-branch}}"
          echo "‚úì Commit: {{workflow.parameters.git-commit-sha}}"
    outputs:
      artifacts:
      - name: source
        path: /workspace
        archive:
          tar:
            compressionLevel: 1  # Faster compression

  - name: npm-install
    inputs:
      artifacts:
      - name: source
        path: /workspace
    container:
      image: node:18-alpine
      workingDir: /workspace
      command: [sh, -c]
      args:
        - |
          echo "üì¶ Installing dependencies..."

          if [ -f package-lock.json ]; then
            npm ci --only=production
          else
            npm install --only=production
          fi

          echo "‚úì Dependencies installed"
      resources:
        requests:
          memory: "512Mi"
          cpu: "500m"
        limits:
          memory: "2Gi"
          cpu: "2000m"
    outputs:
      artifacts:
      - name: source
        path: /workspace
        archive:
          tar:
            compressionLevel: 1  # Faster compression

  - name: run-tests
    inputs:
      artifacts:
      - name: source
        path: /workspace
    container:
      image: node:18-alpine
      workingDir: /workspace
      command: [sh, -c]
      args:
        - |
          echo "üß™ Running tests..."

          if ! grep -q '"test"' package.json; then
            echo "‚ö†Ô∏è  No test script found, skipping tests"
            exit 0
          fi

          npm test || echo "‚ö†Ô∏è  Tests failed but continuing..."
          echo "‚úì Tests completed"
      resources:
        requests:
          memory: "512Mi"
          cpu: "500m"
        limits:
          memory: "1Gi"
          cpu: "1000m"
    outputs:
      artifacts:
      - name: source
        path: /workspace
        archive:
          tar:
            compressionLevel: 1  # Faster compression

  - name: build-nextjs
    inputs:
      artifacts:
      - name: source
        path: /workspace
    container:
      image: node:18-alpine
      workingDir: /workspace
      command: [sh, -c]
      args:
        - |
          echo "üèóÔ∏è  Building Next.js application..."

          export NODE_ENV=production
          export NEXT_TELEMETRY_DISABLED=1

          npm run build

          echo "‚úì Next.js build completed"

          if [ -d .next ]; then
            echo "üìä Build output size:"
            du -sh .next
          fi
      resources:
        requests:
          memory: "1Gi"
          cpu: "1000m"
        limits:
          memory: "4Gi"
          cpu: "2000m"
    outputs:
      artifacts:
      - name: source
        path: /workspace
        archive:
          tar:
            compressionLevel: 1  # Faster compression

  - name: docker-build
    inputs:
      artifacts:
      - name: source
        path: /workspace
    container:
      image: gcr.io/kaniko-project/executor:v1.9.0
      workingDir: /workspace
      command: [/kaniko/executor]
      args:
        - --dockerfile=/workspace/{{DOCKERFILE_PATH}}
        - --context=/workspace
        - --destination={{workflow.parameters.image-name}}:{{workflow.parameters.git-commit-sha}}
        - --destination={{workflow.parameters.image-name}}:latest
        - --cache=true
        - --cache-ttl=24h
        - --compressed-caching=false
        - --snapshot-mode=redo
        - --log-format=text
        - --verbosity=info
      volumeMounts:
      - name: docker-config
        mountPath: /kaniko/.docker/
      resources:
        requests:
          memory: "512Mi"
          cpu: "500m"
        limits:
          memory: "2Gi"
          cpu: "2000m"

  # Build complete - Image Updater will handle deployment
  # The workflow only builds and pushes the image
  # ArgoCD Image Updater will:
  # 1. Detect new image tag in registry (polls every 2 minutes)
  # 2. Update the deployment via Kubernetes API
  # 3. ArgoCD will sync the changes
